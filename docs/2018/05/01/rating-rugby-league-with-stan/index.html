<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

<head>
<title>R, it&#39;s OK I guess - Rating rugby league with Stan</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="R, it&#39;s OK I guess">
<meta name="generator" content="Hugo 0.26" />

  



<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">


    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/grids-responsive-min.css">








<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link rel="stylesheet" href="../../../../css/tuftesque.css">

</head>

<body>
<div id="layout" class="pure-g">
<article class="pure-u-1">
<header class="brand">
  <h1>
    <a href="../../../../">
      <span id = "blog_logo">
        
          <img src=http://www.utsc.utoronto.ca/~butler/156-front.jpg alt="Blog Logo" style="height: 40px; width:40px">
        
      </span>
      
    </a>
  </h1>
</header>

<section>
  <h1 class="content-title">
  
  <a href="../../../../2018/05/01/rating-rugby-league-with-stan/">Rating rugby league with Stan</a>
  
  </h1>
  
  
  
  <span class="content-meta">
    
  
  
  
  <i class="fa fa-user">&nbsp;</i><span class="author">
    &nbsp;Ken</span> <br>
    
  
  
  
  <i class="fa fa-calendar"></i>
    &nbsp;May 1, 2018
  
  
  
  &nbsp;<i class="fa fa-clock-o"></i>
    &nbsp;16 min read
  
  
  
  <br>
    <i class="fa fa-tags"> </i>
    
    <a  href="../../../../categories/bayesian">Bayesian</a>
    
    <a  href="../../../../categories/r">R</a>
    
    
    </span>
    
    
    </section>


<section><div id="introduction" class="section level2">
<h2>Introduction</h2>
<p><a href="https://en.wikipedia.org/wiki/Rugby_league">Rugby League</a> is one of the “football” family of sports, in which players gain ground by carrying and passing the ball (like Rugby Union, North American football and somewhat like Australian and Gaelic football). The aim of the game is to touch the ball down behind the opponents’ goal line (a “try”, four points) after which a kick is taken at goal (a “conversion”, two points). These typically make up most of the scoring, but teams can also score a penalty goal for two points or a drop goal for one, usually near the end of a close game.</p>
<p>Rugby League began in the late 1800s after a dispute about whether players should be paid (as compensation for taking time off work to play). It has thus been a professional game from the start, unlike Rugby Union which was until relatively recently an amateur game. Rugby League differs from Rugby Union in two important respects:</p>
<ul>
<li>thirteen players a side instead of fifteen</li>
<li>after a tackle, play stops long enough for the tackled player to get up and for the defence to retreat, and play restarts with the tackled player rolling the ball back to the “dummy half” behind him. This is in principle similar to American football, but the restart of play happens immediately, and so play is effectively continuous.</li>
</ul>
<p>Most of Rugby League’s clubs are from northern England and the Sydney area of Australia. The sport is also important in the Pacific islands.</p>
</div>
<div id="data" class="section level2">
<h2>Data</h2>
<p>I visited <a href="https://www.loverugbyleague.com/results/">this page</a> and copy-pasted this season’s results in the English and Australian top leagues into a spreadsheet, like this:</p>
<p><img src="../../../../ss.png" /></p>
<p>There is only a single column of text, so I might just as well have pasted it into a text file (or used something like <code>rvest</code> to scrape the page). In any case, it comes to R as a single column of text that will need some processing. We begin by loading some packages:</p>
<pre class="r"><code>library(rstan)</code></pre>
<pre><code>## Loading required package: ggplot2</code></pre>
<pre><code>## Loading required package: StanHeaders</code></pre>
<pre><code>## rstan (Version 2.17.2, GitRev: 2e1f913d3ca3)</code></pre>
<pre><code>## For execution on a local, multicore CPU with excess RAM we recommend calling
## options(mc.cores = parallel::detectCores()).
## To avoid recompilation of unchanged Stan programs, we recommend calling
## rstan_options(auto_write = TRUE)</code></pre>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## ── Attaching packages ─────────────────────────────────────────────────────────────────────────── tidyverse 1.2.1 ──</code></pre>
<pre><code>## ✔ tibble  1.4.2     ✔ purrr   0.2.4
## ✔ tidyr   0.8.0     ✔ dplyr   0.7.4
## ✔ readr   1.1.1     ✔ stringr 1.3.0
## ✔ tibble  1.4.2     ✔ forcats 0.3.0</code></pre>
<pre><code>## ── Conflicts ────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ tidyr::extract() masks rstan::extract()
## ✖ dplyr::filter()  masks stats::filter()
## ✖ dplyr::lag()     masks stats::lag()</code></pre>
<pre class="r"><code>library(readxl)
library(lubridate)</code></pre>
<pre><code>## 
## Attaching package: &#39;lubridate&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:base&#39;:
## 
##     date</code></pre>
<p>These are, respectively, for Bayesian modelling (later), the usual data tidying stuff, reading in Excel files, and handling dates and times (which we will be doing shortly).</p>
<p>Humble beginnings:</p>
<pre class="r"><code>rl=read_excel(&quot;/home/ken/Documents/rugby-league.xlsx&quot;,col_names = &quot;res&quot;,sheet=2)
rl</code></pre>
<pre><code>## # A tibble: 353 x 1
##    res                                               
##    &lt;chr&gt;                                             
##  1 Sun 29th Apr                                      
##  2 York City Knights 144 - 0 West Wales Raiders RL L1
##  3 Workington Town 10 - 32 Oldham RLFC L1            
##  4 Newcastle Thunder 28 - 10 Hunslet RLFC L1         
##  5 Keighley Cougars 24 - 30 Whitehaven RLFC L1       
##  6 Doncaster RLFC 6 - 32 Bradford Bulls L1           
##  7 Coventry Bears 20 - 28 London Skolars L1          
##  8 North Wales Crusaders 40 - 16 Hemel Stags L1      
##  9 Rochdale Hornets 16 - 38 Sheffield Eagles CH      
## 10 Leigh Centurions 46 - 18 Barrow Raiders CH        
## # ... with 343 more rows</code></pre>
<p>The layout of things:</p>
<ul>
<li>the name of the home team</li>
<li>a space, then the score of the home team</li>
<li>a space, a dash, then a space</li>
<li>the score of the away team, then a space</li>
<li>the name of the away team, then a space</li>
<li>a designator for the league in which the match was played:
<ul>
<li>SL (top level in England)</li>
<li>CH (second level in England)</li>
<li>L1 (third level in England)</li>
<li>CC (a national knockout tournament)</li>
<li>NRL (Australian national league)</li>
</ul></li>
</ul>
<p>Many of the team names have spaces in them, and so simply splitting at spaces will entail more processing.</p>
<p>Before that, though, note that we have two kinds of lines here: one containing a date (and no results), which is the date for all the matches between it and the next date. Lines containing dates are easy to identify since they have <em>no</em> space-dash-space in them anywhere. So let’s begin by identifying whether each line is a “result” or not (a date). <code>str_detect</code> from <code>stringr</code> returns <code>TRUE</code> if the second thing is contained anywhere within each item of the first thing, which in this case will yield <code>TRUE</code> if the line refers to a game result and not a date:</p>
<pre class="r"><code>rl %&gt;% mutate(isres=str_detect(res,&quot; - &quot;))</code></pre>
<pre><code>## # A tibble: 353 x 2
##    res                                                isres
##    &lt;chr&gt;                                              &lt;lgl&gt;
##  1 Sun 29th Apr                                       F    
##  2 York City Knights 144 - 0 West Wales Raiders RL L1 T    
##  3 Workington Town 10 - 32 Oldham RLFC L1             T    
##  4 Newcastle Thunder 28 - 10 Hunslet RLFC L1          T    
##  5 Keighley Cougars 24 - 30 Whitehaven RLFC L1        T    
##  6 Doncaster RLFC 6 - 32 Bradford Bulls L1            T    
##  7 Coventry Bears 20 - 28 London Skolars L1           T    
##  8 North Wales Crusaders 40 - 16 Hemel Stags L1       T    
##  9 Rochdale Hornets 16 - 38 Sheffield Eagles CH       T    
## 10 Leigh Centurions 46 - 18 Barrow Raiders CH         T    
## # ... with 343 more rows</code></pre>
<p>Next we define a column <code>date</code> to be the date (if that’s what the line is, otherwise empty) and a column <code>result</code> to be the result, or empty, ditto. I got rid of the original <code>res</code> at the end of this process so you can see what there is more easily:</p>
<pre class="r"><code>rl %&gt;% mutate(isres=str_detect(res,&quot; - &quot;)) %&gt;% 
  mutate(date=ifelse(isres,&quot;&quot;,res),
         result=ifelse(isres,res,&quot;&quot;)) %&gt;% 
  select(-res)</code></pre>
<pre><code>## # A tibble: 353 x 3
##    isres date         result                                            
##    &lt;lgl&gt; &lt;chr&gt;        &lt;chr&gt;                                             
##  1 F     Sun 29th Apr &quot;&quot;                                                
##  2 T     &quot;&quot;           York City Knights 144 - 0 West Wales Raiders RL L1
##  3 T     &quot;&quot;           Workington Town 10 - 32 Oldham RLFC L1            
##  4 T     &quot;&quot;           Newcastle Thunder 28 - 10 Hunslet RLFC L1         
##  5 T     &quot;&quot;           Keighley Cougars 24 - 30 Whitehaven RLFC L1       
##  6 T     &quot;&quot;           Doncaster RLFC 6 - 32 Bradford Bulls L1           
##  7 T     &quot;&quot;           Coventry Bears 20 - 28 London Skolars L1          
##  8 T     &quot;&quot;           North Wales Crusaders 40 - 16 Hemel Stags L1      
##  9 T     &quot;&quot;           Rochdale Hornets 16 - 38 Sheffield Eagles CH      
## 10 T     &quot;&quot;           Leigh Centurions 46 - 18 Barrow Raiders CH        
## # ... with 343 more rows</code></pre>
<p>Those dates are text, but I can make them into real dates using <code>lubridate</code>. They are all year 2018, so if I glue the year onto the end, they are in day-month-year order, so <code>dmy</code> will parse them:</p>
<pre class="r"><code>rl %&gt;% mutate(isres=str_detect(res,&quot; - &quot;)) %&gt;% 
  mutate(date=ifelse(isres,&quot;&quot;,res),
         result=ifelse(isres,res,&quot;&quot;)) %&gt;% 
  select(-res) %&gt;% 
  mutate(date=dmy(str_c(date,&quot; 2018&quot;)))</code></pre>
<pre><code>## Warning: 295 failed to parse.</code></pre>
<pre><code>## # A tibble: 353 x 3
##    isres date       result                                            
##    &lt;lgl&gt; &lt;date&gt;     &lt;chr&gt;                                             
##  1 F     2018-04-29 &quot;&quot;                                                
##  2 T     NA         York City Knights 144 - 0 West Wales Raiders RL L1
##  3 T     NA         Workington Town 10 - 32 Oldham RLFC L1            
##  4 T     NA         Newcastle Thunder 28 - 10 Hunslet RLFC L1         
##  5 T     NA         Keighley Cougars 24 - 30 Whitehaven RLFC L1       
##  6 T     NA         Doncaster RLFC 6 - 32 Bradford Bulls L1           
##  7 T     NA         Coventry Bears 20 - 28 London Skolars L1          
##  8 T     NA         North Wales Crusaders 40 - 16 Hemel Stags L1      
##  9 T     NA         Rochdale Hornets 16 - 38 Sheffield Eagles CH      
## 10 T     NA         Leigh Centurions 46 - 18 Barrow Raiders CH        
## # ... with 343 more rows</code></pre>
<p>The “dates” that are empty cannot be parsed as dates, so they are turned into missing values.</p>
<p>The reason for making the dates into real dates was so that they could be used as the dates for the game results. What we want to do is to replace all those <code>NA</code> values by the previous non-missing value, all the way down. This is a task that comes up often enough that <code>tidyr</code> has a function to do exactly that, called <code>fill</code>. By default it fills down from the previous non-missing value, which is what we want. (It can also be made to fill upwards from the <em>next</em> non-missing value.):</p>
<pre class="r"><code>rl %&gt;% mutate(isres=str_detect(res,&quot; - &quot;)) %&gt;% 
  mutate(date=ifelse(isres,&quot;&quot;,res),
         result=ifelse(isres,res,&quot;&quot;)) %&gt;% 
  select(-res) %&gt;% 
  mutate(date=dmy(str_c(date,&quot; 2018&quot;))) %&gt;% 
  fill(date)</code></pre>
<pre><code>## Warning: 295 failed to parse.</code></pre>
<pre><code>## # A tibble: 353 x 3
##    isres date       result                                            
##    &lt;lgl&gt; &lt;date&gt;     &lt;chr&gt;                                             
##  1 F     2018-04-29 &quot;&quot;                                                
##  2 T     2018-04-29 York City Knights 144 - 0 West Wales Raiders RL L1
##  3 T     2018-04-29 Workington Town 10 - 32 Oldham RLFC L1            
##  4 T     2018-04-29 Newcastle Thunder 28 - 10 Hunslet RLFC L1         
##  5 T     2018-04-29 Keighley Cougars 24 - 30 Whitehaven RLFC L1       
##  6 T     2018-04-29 Doncaster RLFC 6 - 32 Bradford Bulls L1           
##  7 T     2018-04-29 Coventry Bears 20 - 28 London Skolars L1          
##  8 T     2018-04-29 North Wales Crusaders 40 - 16 Hemel Stags L1      
##  9 T     2018-04-29 Rochdale Hornets 16 - 38 Sheffield Eagles CH      
## 10 T     2018-04-29 Leigh Centurions 46 - 18 Barrow Raiders CH        
## # ... with 343 more rows</code></pre>
<p>Now, the lines containing just dates have served their purpose (the ones for which <code>isres</code> is <code>FALSE</code>), and once we gotten rid of those lines, we can get rid of the column <code>isres</code> too:</p>
<pre class="r"><code>rl %&gt;% mutate(isres=str_detect(res,&quot; - &quot;)) %&gt;% 
  mutate(date=ifelse(isres,&quot;&quot;,res),
         result=ifelse(isres,res,&quot;&quot;)) %&gt;% 
  select(-res) %&gt;% 
  mutate(date=dmy(str_c(date,&quot; 2018&quot;))) %&gt;% 
  fill(date) %&gt;% 
  filter(isres) %&gt;% 
  select(-isres) -&gt;
rl2</code></pre>
<pre><code>## Warning: 295 failed to parse.</code></pre>
<pre class="r"><code>rl2</code></pre>
<pre><code>## # A tibble: 290 x 2
##    date       result                                            
##    &lt;date&gt;     &lt;chr&gt;                                             
##  1 2018-04-29 York City Knights 144 - 0 West Wales Raiders RL L1
##  2 2018-04-29 Workington Town 10 - 32 Oldham RLFC L1            
##  3 2018-04-29 Newcastle Thunder 28 - 10 Hunslet RLFC L1         
##  4 2018-04-29 Keighley Cougars 24 - 30 Whitehaven RLFC L1       
##  5 2018-04-29 Doncaster RLFC 6 - 32 Bradford Bulls L1           
##  6 2018-04-29 Coventry Bears 20 - 28 London Skolars L1          
##  7 2018-04-29 North Wales Crusaders 40 - 16 Hemel Stags L1      
##  8 2018-04-29 Rochdale Hornets 16 - 38 Sheffield Eagles CH      
##  9 2018-04-29 Leigh Centurions 46 - 18 Barrow Raiders CH        
## 10 2018-04-29 Featherstone Rovers 50 - 12 Batley Bulldogs CH    
## # ... with 280 more rows</code></pre>
<p>I am using the right-arrow to assign the result to <code>rl2</code>, which I put, unindented, on the next line, to remind myself that I am creating this new data frame.</p>
<p>Now we have to deal with that <code>result</code> column.
I learned Perl, which is a great language for handling text like this. The idea there is that you use a “regular expression” with “capture groups” to identify and extract the things you want. A similar <code>tidyverse</code> functionality lives in <code>extract</code> from <code>tidyr</code>. I’m doing to do this in three steps. The first step is to separate <code>result</code> into the bit before the space-dash-space. In fact, I can use <code>separate</code> for this bit:</p>
<pre class="r"><code>rl2 %&gt;% 
  separate(result,into=c(&quot;first&quot;,&quot;second&quot;),sep=&quot; - &quot;)</code></pre>
<pre><code>## # A tibble: 290 x 3
##    date       first                    second                    
##    &lt;date&gt;     &lt;chr&gt;                    &lt;chr&gt;                     
##  1 2018-04-29 York City Knights 144    0 West Wales Raiders RL L1
##  2 2018-04-29 Workington Town 10       32 Oldham RLFC L1         
##  3 2018-04-29 Newcastle Thunder 28     10 Hunslet RLFC L1        
##  4 2018-04-29 Keighley Cougars 24      30 Whitehaven RLFC L1     
##  5 2018-04-29 Doncaster RLFC 6         32 Bradford Bulls L1      
##  6 2018-04-29 Coventry Bears 20        28 London Skolars L1      
##  7 2018-04-29 North Wales Crusaders 40 16 Hemel Stags L1         
##  8 2018-04-29 Rochdale Hornets 16      38 Sheffield Eagles CH    
##  9 2018-04-29 Leigh Centurions 46      18 Barrow Raiders CH      
## 10 2018-04-29 Featherstone Rovers 50   12 Batley Bulldogs CH     
## # ... with 280 more rows</code></pre>
<p>Now we can’t use <code>separate</code> any more, because sometimes space separates the thing we want, and sometimes it separates words in a team name. This is where <code>extract</code> comes in, as we tackle part 2.</p>
<p><code>first</code> contains some text (the home team’s name), then a space, then one or more digits, then the end of the string. The following extracts those pieces (I explain my regular expression below):</p>
<pre class="r"><code>rl2 %&gt;% 
  separate(result,into=c(&quot;first&quot;,&quot;second&quot;),sep=&quot; - &quot;) %&gt;% 
  tidyr::extract(first,c(&quot;t1&quot;,&quot;s1&quot;),&quot;(.*)\\s(\\d+)$&quot;) </code></pre>
<pre><code>## # A tibble: 290 x 4
##    date       t1                    s1    second                    
##    &lt;date&gt;     &lt;chr&gt;                 &lt;chr&gt; &lt;chr&gt;                     
##  1 2018-04-29 York City Knights     144   0 West Wales Raiders RL L1
##  2 2018-04-29 Workington Town       10    32 Oldham RLFC L1         
##  3 2018-04-29 Newcastle Thunder     28    10 Hunslet RLFC L1        
##  4 2018-04-29 Keighley Cougars      24    30 Whitehaven RLFC L1     
##  5 2018-04-29 Doncaster RLFC        6     32 Bradford Bulls L1      
##  6 2018-04-29 Coventry Bears        20    28 London Skolars L1      
##  7 2018-04-29 North Wales Crusaders 40    16 Hemel Stags L1         
##  8 2018-04-29 Rochdale Hornets      16    38 Sheffield Eagles CH    
##  9 2018-04-29 Leigh Centurions      46    18 Barrow Raiders CH      
## 10 2018-04-29 Featherstone Rovers   50    12 Batley Bulldogs CH     
## # ... with 280 more rows</code></pre>
<p>The inputs to <code>extract</code> are: some text that we want to pull something out of, new columns to store the results in, and a regular expression that provides a recipe for what to pull out. My regular expression contains:</p>
<ul>
<li><code>.</code> matches any single character</li>
<li><code>*</code> matches zero of more of the preceding, so <code>.*</code> means to match zero or more of any characters</li>
<li><code>()</code> around part of a regular expression makes a “capture group”: <code>(.*)</code> gets saved in <code>t1</code> (the home team’s name)</li>
<li><code>\\s</code> matches exactly one whitespace character (space or tab)</li>
<li><code>\\d</code> matches exactly one numeric digit 0 through 9</li>
<li><code>+</code> matches one or more of the preceding, so <code>\\d+</code> matches one or more digits</li>
<li><code>(\\d+)</code> matches one or more digits and captures the result, so that <code>s1</code> contains the home team’s score</li>
<li><code>$</code> matches the end of the text, so that the digits have to be right at the end. (This would help if a team was called something like “Bassenthwaite Wanderers RLFC (1897)”, with numbers <em>in</em> it.)</li>
</ul>
<p>If you were wondering how <code>.*</code> knew to match everything except the numbers at the end: well, regular expressions are by default “greedy” in that they match as much as possible such that the whole regular expression will still match something. In this case, <code>.*</code> can match everything up to (but not including) the space before the score, and “space then some digits then the end” will match the score, so it still works.</p>
<p>Part three is to do the same thing to <code>second</code>. This is a teeny bit more complicated, but the same idea: the beginning of the string, some digits (the away team’s score), a space, some text (the away team’s name), a space, some more text that does not contain spaces (league designator), end of the string. So the regular expression shown below will catch it:</p>
<pre class="r"><code>rl2 %&gt;% 
  separate(result,into=c(&quot;first&quot;,&quot;second&quot;),sep=&quot; - &quot;) %&gt;% 
  tidyr::extract(first,c(&quot;t1&quot;,&quot;s1&quot;),&quot;(.*)\\s(\\d+)$&quot;) %&gt;% 
  tidyr::extract(second,c(&quot;s2&quot;,&quot;t2&quot;,&quot;lg&quot;),&quot;^(\\d+)\\s(.*)\\s([^ ]+)$&quot;) %&gt;% 
  mutate(diff=as.numeric(s1)-as.numeric(s2)) -&gt;
games
games</code></pre>
<pre><code>## # A tibble: 290 x 7
##    date       t1                    s1    s2    t2           lg       diff
##    &lt;date&gt;     &lt;chr&gt;                 &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;   &lt;dbl&gt;
##  1 2018-04-29 York City Knights     144   0     West Wales … L1     144   
##  2 2018-04-29 Workington Town       10    32    Oldham RLFC  L1    - 22.0 
##  3 2018-04-29 Newcastle Thunder     28    10    Hunslet RLFC L1      18.0 
##  4 2018-04-29 Keighley Cougars      24    30    Whitehaven … L1    -  6.00
##  5 2018-04-29 Doncaster RLFC        6     32    Bradford Bu… L1    - 26.0 
##  6 2018-04-29 Coventry Bears        20    28    London Skol… L1    -  8.00
##  7 2018-04-29 North Wales Crusaders 40    16    Hemel Stags  L1      24.0 
##  8 2018-04-29 Rochdale Hornets      16    38    Sheffield E… CH    - 22.0 
##  9 2018-04-29 Leigh Centurions      46    18    Barrow Raid… CH      28.0 
## 10 2018-04-29 Featherstone Rovers   50    12    Batley Bull… CH      38.0 
## # ... with 280 more rows</code></pre>
<p>The <code>[^ ]</code> is called a “character class”. This one means “anything that does not match space”, so the third capture group, the one saved into <code>lg</code>, is “one or more non-spaces”. Finally, I create a column called <code>diff</code> that is the difference between the home and away team’s scores, bearing in mind that <code>s1</code> and <code>s2</code> are both text. (A positive <code>diff</code> means that the home team won.)</p>
<p>I save this into a data frame called <code>games</code>. This is what we will use for modelling later.</p>
</div>
<div id="a-bayesian-model-for-rugby-league" class="section level2">
<h2>A Bayesian model for rugby league</h2>
<p>It might be possible to model the actual point-scoring process: maybe a Poisson model for tries (with mean depending on the team strength), conversions successfully kicked with a certain probability (that might vary by team). But then there are penalty goals and drop goals, which are typically kicked near the end of a game, <em>if</em> they are close enough to goal to stand a reasonable chance of success, and <em>if</em> the extra two points or one point are enough to substantially improve a team’s chance of winning the game. (A team leading by six points might kick a drop goal to lead by seven and force the other side to score twice instead of being able to level the score with a converted try.)</p>
<p>So I gave up on that idea and went with something a lot simpler. I decided to model the score difference as having a normal distribution with mean that depended on the relative strengths of the teams (the difference between their “ratings”), and a standard deviation that was fixed for all games (to be estimated). I could have also used something like a <span class="math inline">\(t\)</span> distribution with degrees of freedom to be estimated, which might better account for freak results, but this seemed to be a good place to start.</p>
<p>As in <a href="http://ritsokiguess.site/docs/2018/02/28/working-my-way-back-to-you-a-re-investigation-of-rstan/">my other blog post about Stan</a>, I piece the Stan code together step by step. I assert that each team has a rating <code>rat</code>, and I let <code>sigma_diff</code> be the (unknown) SD of score differences. I can compute the rating differences game by game. I seem to get the best results in Stan if I calculate things step by step, so my likelihood part looks like this:</p>
<pre><code>model {
  // likelihood
  for (i in 1:ng) {
    o1=t1[i];
    o2=t2[i];
    ratdiff[i]=rat[o1]-rat[o2];
  } 
  diff ~ normal(ratdiff, sigma_diff);
}</code></pre>
<p>I realized coding this that the teams would have to have <em>numbers</em> rather than names, because Stan arrays have integer subscripts. Thus <code>t1[i]</code> is the home team in game <code>i</code> (an integer), and <code>rat[o1]</code> is the rating of team number <code>o1</code>. The sampling step at the bottom works just fine on vectors, so that can be outside the loop.</p>
<p><code>ng</code> is the number of games. Elsewhere I need <code>nt</code> to be the number of teams.</p>
<p>Now I have to tidy up after myself. <code>t1</code> and <code>t2</code> are data, and <code>diff</code> will be data also. <code>o1</code>, <code>o2</code> and <code>ratdiff</code> are calculated here, so they will have to be declared. <code>rat</code> and <code>sigma_diff</code> are parameters, so they will need to be given prior distributions and declared in a <code>parameters</code> section. A normal prior for <code>rat</code> seems reasonable, with an SD that will be part of the data; also it seems easiest to have a chi-squared prior for <code>sigma_diff</code> with a df (mean) that will also be part of the data.</p>
<p>All of which leads me to this:</p>
<pre><code>data {
  int&lt;lower=2&gt; nt;
  int&lt;lower=2&gt; ng;
  real&lt;lower=0&gt; sigma_prior;
  real&lt;lower=0&gt; sigma_diff_mean;
  int&lt;lower=1&gt; t1[ng];
  int&lt;lower=1&gt; t2[ng];
  real diff[ng];
}

parameters {
  real&lt;lower=0&gt; sigma_diff;
  real rat[nt];
}

model {
  int o1;
  int o2;
  real ratdiff[ng];
  // prior
  rat ~ normal(0, sigma_prior);
  sigma_diff ~ chi_square(sigma_diff_mean);
  // likelihood
  for (i in 1:ng) {
    o1=t1[i];
    o2=t2[i];
    ratdiff[i]=rat[o1]-rat[o2];
  } 
  diff ~ normal(ratdiff, sigma_diff);
}</code></pre>
<p>For model-checking I would add a <code>generated quantities</code> section to simulate predictive distributions (which I would then compare with the data). But that’s for later.</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p><a href="https://en.wikipedia.org/wiki/Rugby_league">Wikipedia article on rugby league</a></p>
<p><a href="http://tidyr.tidyverse.org/reference/extract.html">Tidyverse help page on <code>extract</code></a></p>
</div>
</section>
<section>
  

  



  <div id="disqus_thread"></div>
<script>
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://kens-blog-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  <footer class="page-footer">
		<hr>
		<ul class="page-footer-menu">
		
		</ul>

  

	<div class="copyright">
	<p>
    
      &copy; 2018
    .
    All rights reserved.
    
  </p>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    });
    </script>
    <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</footer>

</section>
</article>
</div>
</body>
</html>

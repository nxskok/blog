<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.20.6" />


<title>Carter and Guthrie - Ken&#39;s Blog</title>
<meta property="og:title" content="Carter and Guthrie - Ken&#39;s Blog">



  








<link href='//cdn.bootcss.com/highlight.js/9.10.0/styles/github.min.css' rel='stylesheet' type='text/css'>



<link rel="stylesheet" href="../../../../css/fonts.css" media="all">
<link rel="stylesheet" href="../../../../css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="../../../../" class="nav-logo">
    <img src="../../../../images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="https://github.com/nxskok">GitHub</a></li>
    
    <li><a href="../../../../about/">Ken Butler</a></li>
    
    <li><a href="https://twitter.com/kenbutler12">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">21 min read</span>
    

    <h1 class="article-title">Carter and Guthrie</h1>

    
    <span class="article-date">2017/05/31</span>
    

    <div class="article-content">
      <div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Carter and Guthrie, in 2004, proposed a method of modelling cricket matches. Their aim was to provide an alternative method of deciding interrupted matches, in the manner of Duckworth and Lewis. What was interesting to me is that they estimate a <em>probability</em> of winning (which is then held fixed over interruptions), and it seemed to me that one could estimate and update the probability of winning as the game progresses, which would be a useful adjunct for spectators.</p>
<p>Data for the update come from <code>yorkrdata</code>, by the author of the R package <code>yorkr</code>.</p>
</div>
<div id="gathering-and-arranging-data" class="section level1">
<h1>Gathering and arranging data</h1>
<div id="getting-a-match-file" class="section level2">
<h2>Getting a match file</h2>
<p>Start with the <code>tidyverse</code>:</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## Loading tidyverse: ggplot2
## Loading tidyverse: tibble
## Loading tidyverse: tidyr
## Loading tidyverse: readr
## Loading tidyverse: purrr
## Loading tidyverse: dplyr</code></pre>
<pre><code>## Conflicts with tidy packages ----------------------------------------------</code></pre>
<pre><code>## filter(): dplyr, stats
## lag():    dplyr, stats</code></pre>
<p>The data in <code>yorkrdata</code> are in the form of <code>.RData</code> files (saved dataframes), which were downloaded as a <code>.zip</code> file and extracted to the working directory. One such file is <code>Afghanistan-Bangladesh-2015-02-18.RData</code>. It will be convenient to write a function for reading in files of this kind:</p>
<pre class="r"><code>readMatch=function(fname) {
  load(fname)
  overs
}</code></pre>
<p>The data frame for each match was originally called <code>overs</code>, so when it is <code>load</code>ed, it acquires the name it had when it was <code>save</code>d. This is inconvenient, so I abstract it into a function.</p>
<p>What does one of these data frames contain?</p>
<pre class="r"><code>fname=&quot;Afghanistan-Bangladesh-2015-02-18.RData&quot;
d=readMatch(fname)
glimpse(d)</code></pre>
<pre><code>## Observations: 565
## Variables: 25
## $ ball            &lt;chr&gt; &quot;1st.0.1&quot;, &quot;1st.0.2&quot;, &quot;1st.0.3&quot;, &quot;1st.0.4&quot;, &quot;1...
## $ team            &lt;fctr&gt; Bangladesh, Bangladesh, Bangladesh, Banglades...
## $ batsman         &lt;fctr&gt; Anamul Haque, Anamul Haque, Anamul Haque, Ana...
## $ bowler          &lt;fctr&gt; Hamid Hassan, Hamid Hassan, Hamid Hassan, Ham...
## $ nonStriker      &lt;fctr&gt; Tamim Iqbal, Tamim Iqbal, Tamim Iqbal, Tamim ...
## $ byes            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0...
## $ legbyes         &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0...
## $ noballs         &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0...
## $ wides           &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0...
## $ nonBoundary     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0...
## $ penalty         &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0...
## $ runs            &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0...
## $ extras          &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0...
## $ totalRuns       &lt;dbl&gt; 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0...
## $ wicketFielder   &lt;chr&gt; &quot;nobody&quot;, &quot;nobody&quot;, &quot;nobody&quot;, &quot;nobody&quot;, &quot;nobod...
## $ wicketKind      &lt;chr&gt; &quot;not-out&quot;, &quot;not-out&quot;, &quot;not-out&quot;, &quot;not-out&quot;, &quot;n...
## $ wicketPlayerOut &lt;chr&gt; &quot;nobody&quot;, &quot;nobody&quot;, &quot;nobody&quot;, &quot;nobody&quot;, &quot;nobod...
## $ date            &lt;date&gt; 2015-02-18, 2015-02-18, 2015-02-18, 2015-02-1...
## $ matchType       &lt;fctr&gt; ODI, ODI, ODI, ODI, ODI, ODI, ODI, ODI, ODI, ...
## $ overs           &lt;dbl&gt; 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50...
## $ venue           &lt;fctr&gt; Manuka Oval, Manuka Oval, Manuka Oval, Manuka...
## $ team1           &lt;fctr&gt; Afghanistan, Afghanistan, Afghanistan, Afghan...
## $ team2           &lt;fctr&gt; Bangladesh, Bangladesh, Bangladesh, Banglades...
## $ winner          &lt;fctr&gt; Bangladesh, Bangladesh, Bangladesh, Banglades...
## $ result          &lt;chr&gt; &quot;NA&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;NA&quot;, &quot;NA&quot;...</code></pre>
<p>The data frame contains one row for each ball. The columns include a coded representation of innings (team batting first or second), over and ball within over, the name of the batsman and bowler, the number of runs from that ball (regular <code>runs</code> and the various types of extras), the kind of wicket from that ball (if any), and at the end, some information about the match: the date, the type of match, the number of overs per side, the venue, the names of the teams, the winner and the result. These last are the same thing repeated on every line.</p>
<p>It will be convenient to have a function that returns some information about the match from its filename:</p>
<pre class="r"><code>matchInfo=function(fname) {
  d=readMatch(fname)
  data.frame(fname=fname,date=d$date[1],type=d$matchType[1])
}</code></pre>
<p>and to test it:</p>
<pre class="r"><code>matchInfo(fname)</code></pre>
<pre><code>##                                     fname       date type
## 1 Afghanistan-Bangladesh-2015-02-18.RData 2015-02-18  ODI</code></pre>
</div>
<div id="data-frame-of-what-we-want" class="section level2">
<h2>Data frame of what we want</h2>
<p>We don’t need all the information in the match data frame, and we do need to re-process some of what there is. Specifically:</p>
<ul>
<li>grab the ball code and the scoring info</li>
<li>separate out the ball code into the inns, over and ball within that innings</li>
<li>create new variables, making sure that numeric things are numeric and that we know whether each ball contains a wicket or is a extra, defined here as a no ball or a wide that will result in another ball. (I should be more careful about counting these, since the number of balls left as calculated later will be slightly wrong.) Other extras, such as leg byes, are treated as regular runs.</li>
<li>the total number of balls so far in the innings</li>
<li>treat each innings separately. The Carter-Guthrie analysis uses only the first innings.</li>
<li>grab only the variables we want.</li>
</ul>
<pre class="r"><code>processMatch=function(fname) {
  readMatch(fname) %&gt;% select(ball,noballs,wides,totalRuns,wicketKind) %&gt;% 
    separate(ball,into=c(&quot;inns&quot;,&quot;over&quot;,&quot;ball&quot;)) %&gt;% 
    group_by(inns) %&gt;% 
    mutate(over=as.numeric(over),
           ball=as.numeric(ball),
           isWkt=(wicketKind!=&quot;not-out&quot;),
           wktDown=cumsum(isWkt),
           isExtra=(noballs+wides&gt;0),
           totalBalls=6*over+ball) %&gt;%
    select(inns,totalBalls,isExtra,isWkt,wktDown,totalRuns)
}</code></pre>
<p>Testing:</p>
<pre class="r"><code>d=processMatch(fname)
d</code></pre>
<pre><code>## Source: local data frame [565 x 6]
## Groups: inns [2]
## 
## # A tibble: 565 x 6
##     inns totalBalls isExtra isWkt wktDown totalRuns
##    &lt;chr&gt;      &lt;dbl&gt;   &lt;lgl&gt; &lt;lgl&gt;   &lt;int&gt;     &lt;dbl&gt;
##  1   1st          1    TRUE FALSE       0         1
##  2   1st          2   FALSE FALSE       0         0
##  3   1st          3   FALSE FALSE       0         0
##  4   1st          4   FALSE FALSE       0         0
##  5   1st          5   FALSE FALSE       0         1
##  6   1st          6   FALSE FALSE       0         0
##  7   1st          7   FALSE FALSE       0         0
##  8   1st          7   FALSE FALSE       0         0
##  9   1st          8   FALSE FALSE       0         1
## 10   1st          9   FALSE FALSE       0         0
## # ... with 555 more rows</code></pre>
<p>It is also useful to summarize a match, as done by the function below</p>
<pre class="r"><code>summarizeMatch=function(fname) {
  processMatch(fname) %&gt;% summarize(
                                 runTotal=max(cumsum(totalRuns)),
                                 wktTotal=max(wktDown),
                                 ballTotal=max(totalBalls)
                                 ) 
}</code></pre>
<p>and to test:</p>
<pre class="r"><code>summarizeMatch(fname)</code></pre>
<pre><code>## # A tibble: 2 x 4
##    inns runTotal wktTotal ballTotal
##   &lt;chr&gt;    &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
## 1   1st      267       10       300
## 2   2nd      162       10       257</code></pre>
<p>The team batting first scored 267 and were all out on the last ball of their 50 overs (300 balls); the team batting second were all out for 162 in the 43rd over, and thus lost by 105 runs.</p>
<p>It will also be necessary to determine whether the innings of the team batting first was “complete” (that is, either the team was all out or batted out the full 50 overs). This could fail to happen because the match is interrupted, and for the estimation, we want to ignore these matches:</p>
<pre class="r"><code>firstComplete=function(fname) {
  summarizeMatch(fname) %&gt;% 
    mutate(complete=ifelse(wktTotal[1]==10,T,ifelse(ballTotal[1]&gt;=300,T,F))) %&gt;% 
    mutate(fname=fname) %&gt;% 
    select(c(fname,complete)) %&gt;% 
    slice(1)
}
firstComplete(fname)</code></pre>
<pre><code>## # A tibble: 1 x 2
##                                     fname complete
##                                     &lt;chr&gt;    &lt;lgl&gt;
## 1 Afghanistan-Bangladesh-2015-02-18.RData     TRUE</code></pre>
</div>
<div id="getting-all-the-files" class="section level2">
<h2>Getting all the files</h2>
<p>The files we want to consider are <code>.RData</code> files <em>with a dash and two numbers before the dot</em> (the tail end of the match date). There are some other <code>.RData</code> files that were in the <code>.zip</code>, but we don’t want to consider those:</p>
<pre class="r"><code>files=list.files(pattern = &quot;-[0-9][0-9].RData$&quot;)
head(files)</code></pre>
<pre><code>## [1] &quot;Afghanistan-Australia-2012-08-25.RData&quot; 
## [2] &quot;Afghanistan-Bangladesh-2015-02-18.RData&quot;
## [3] &quot;Afghanistan-Canada-2012-03-18.RData&quot;    
## [4] &quot;Afghanistan-England-2012-09-21.RData&quot;   
## [5] &quot;Afghanistan-England-2015-03-13.RData&quot;   
## [6] &quot;Afghanistan-Hong Kong-2014-03-18.RData&quot;</code></pre>
<pre class="r"><code>length(files)</code></pre>
<pre><code>## [1] 2099</code></pre>
<p>We are going to apply our functions to a list of filenames (since they all take filenames as input: that was a design decision). Here, each function returns a data frame, so we use <code>map</code> from <code>purrr</code> to produce a <strong>list</strong> of data frames, which we then run through <code>bind_rows</code> to produce a big data frame with these rows stacked atop each other. This is something we’ll be doing a lot, so let’s make a function to do it all. <code>v</code> is a vector (of eg. file names) and <code>f</code> is a function that returns a data frame, so that my <code>xx</code> is a list of data frames:</p>
<pre class="r"><code>atop=function(v,f) {
  xx=map(v,f)
  bind_rows(xx)
}</code></pre>
<p>Since it doesn’t have a data frame as a first argument (I couldn’t make that work), it won’t work in a pipe.</p>
<p>We need to test this, so let’s check whether each of our match files has a complete first innings (which we’ll need to check anyway):</p>
<pre class="r"><code>isComplete=atop(files,firstComplete)
isComplete</code></pre>
<pre><code>## # A tibble: 2,099 x 2
##                                      fname complete
##                                      &lt;chr&gt;    &lt;lgl&gt;
##  1  Afghanistan-Australia-2012-08-25.RData     TRUE
##  2 Afghanistan-Bangladesh-2015-02-18.RData     TRUE
##  3     Afghanistan-Canada-2012-03-18.RData    FALSE
##  4    Afghanistan-England-2012-09-21.RData    FALSE
##  5    Afghanistan-England-2015-03-13.RData    FALSE
##  6  Afghanistan-Hong Kong-2014-03-18.RData    FALSE
##  7  Afghanistan-Hong Kong-2015-07-21.RData    FALSE
##  8      Afghanistan-India-2010-05-01.RData    FALSE
##  9      Afghanistan-India-2012-09-19.RData    FALSE
## 10      Afghanistan-India-2014-03-05.RData     TRUE
## # ... with 2,089 more rows</code></pre>
<p>The second line is the match we’ve been using to test. What is up with the lines here that are <code>FALSE</code>?</p>
<pre class="r"><code>isComplete %&gt;% slice(3:9) -&gt; tmp
atop(tmp$fname,summarizeMatch)</code></pre>
<pre><code>## # A tibble: 14 x 4
##     inns runTotal wktTotal ballTotal
##    &lt;chr&gt;    &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
##  1   1st      174        8       123
##  2   2nd      133        9       121
##  3   1st      196        5       120
##  4   2nd       80       10       104
##  5   1st      111        7       218
##  6   2nd      101        1       109
##  7   1st      153        8       120
##  8   2nd      154        3       108
##  9   1st      161        7       120
## 10   2nd      162        5       121
## 11   1st      115        8       120
## 12   2nd      116        3        89
## 13   1st      159        5       121
## 14   2nd      136       10       117</code></pre>
<p>In each case, a match takes up two lines; we only need the line starting with “1st”. You see that each first innings is not done yet (less than 10 wickets) but the allotted 300 balls have not been used. I guess that these matches were interrupted, with a revised number of overs for at least the team batting second. In any case, we don’t want to include these in our analysis.</p>
<p>In addition, we need to check whether each match is a ODI (which we want to assess) or something else. That’s another application of <code>atop</code>:</p>
<pre class="r"><code>v=atop(files,matchInfo)</code></pre>
<pre><code>## Warning in bind_rows_(x, .id): Unequal factor levels: coercing to character

## Warning in bind_rows_(x, .id): Unequal factor levels: coercing to character</code></pre>
<pre class="r"><code>head(v)</code></pre>
<pre><code>##                                     fname       date type
## 1  Afghanistan-Australia-2012-08-25.RData 2012-08-25  ODI
## 2 Afghanistan-Bangladesh-2015-02-18.RData 2015-02-18  ODI
## 3     Afghanistan-Canada-2012-03-18.RData 2012-03-18  T20
## 4    Afghanistan-England-2012-09-21.RData 2012-09-21  T20
## 5    Afghanistan-England-2015-03-13.RData 2015-03-13  ODI
## 6  Afghanistan-Hong Kong-2014-03-18.RData 2014-03-18  T20</code></pre>
<pre class="r"><code>tab=table(v$type)
tab</code></pre>
<pre><code>## 
##  ODI  T20 
## 1139  960</code></pre>
<p>There are 1139 one-day internationals, and 960 Twenty-20 matches, which are a mixture of internationals and Indian Premier League.</p>
</div>
<div id="getting-all-the-matches-we-want" class="section level2">
<h2>Getting all the matches we want</h2>
<p>To get just the matches we want, we do this:</p>
<ul>
<li>read all the matches’ info</li>
<li>select only the ones whose type is ODI</li>
<li>of those, select the ones that have complete first innings</li>
<li>construct the desired (big) data for these (just first innings)</li>
</ul>
<p>Since <code>atop</code> returns a data frame, we can use it as the <em>start</em> of a pipe:</p>
<pre class="r"><code>atop(files,matchInfo) %&gt;% filter(type==&quot;ODI&quot;) -&gt; odis</code></pre>
<pre><code>## Warning in bind_rows_(x, .id): Unequal factor levels: coercing to character

## Warning in bind_rows_(x, .id): Unequal factor levels: coercing to character</code></pre>
<pre class="r"><code>atop(odis$fname,firstComplete) %&gt;% filter(complete) -&gt; complete.odis
complete.odis</code></pre>
<pre><code>## # A tibble: 1,040 x 2
##                                       fname complete
##                                       &lt;chr&gt;    &lt;lgl&gt;
##  1   Afghanistan-Australia-2012-08-25.RData     TRUE
##  2  Afghanistan-Bangladesh-2015-02-18.RData     TRUE
##  3       Afghanistan-India-2014-03-05.RData     TRUE
##  4     Afghanistan-Ireland-2015-01-17.RData     TRUE
##  5 Afghanistan-Netherlands-2012-03-29.RData     TRUE
##  6    Afghanistan-Pakistan-2012-02-10.RData     TRUE
##  7    Afghanistan-Pakistan-2014-02-27.RData     TRUE
##  8    Afghanistan-Scotland-2009-04-19.RData     TRUE
##  9    Afghanistan-Scotland-2015-01-14.RData     TRUE
## 10    Afghanistan-Scotland-2015-02-26.RData     TRUE
## # ... with 1,030 more rows</code></pre>
<p>There are 1040 complete ODIs. Now to get the actual information, which we can expect to be slow:</p>
<pre class="r"><code>atop(complete.odis$fname,processMatch) %&gt;% 
  filter(inns==&quot;1st&quot;) -&gt; d
d</code></pre>
<pre><code>## Source: local data frame [307,956 x 6]
## Groups: inns [1]
## 
## # A tibble: 307,956 x 6
##     inns totalBalls isExtra isWkt wktDown totalRuns
##    &lt;chr&gt;      &lt;dbl&gt;   &lt;lgl&gt; &lt;lgl&gt;   &lt;int&gt;     &lt;dbl&gt;
##  1   1st          1   FALSE FALSE       0         0
##  2   1st          2   FALSE FALSE       0         0
##  3   1st          3   FALSE FALSE       0         0
##  4   1st          4   FALSE FALSE       0         1
##  5   1st          5   FALSE FALSE       0         0
##  6   1st          6   FALSE FALSE       0         0
##  7   1st          7   FALSE FALSE       0         0
##  8   1st          8   FALSE FALSE       0         0
##  9   1st          9   FALSE FALSE       0         0
## 10   1st         10   FALSE FALSE       0         0
## # ... with 307,946 more rows</code></pre>
<p>307956 rows! But that’s what we need.</p>
</div>
</div>
<div id="estimating-the-parameters" class="section level1">
<h1>Estimating the parameters</h1>
<div id="the-model" class="section level2">
<h2>The model</h2>
<p>The <span class="citation">@carter2004cricket</span> model is a simplified version of cricketing reality, thus:</p>
<ul>
<li>with a certain probability (which is fixed), a ball is an extra (wide or no ball), which counts one run and leads to an extra ball being bowled. (The assumption is that no additional runs are scored, for example runs scored off a no ball.)</li>
<li>otherwise, with a certain probability, which depends on the number of balls and wickets left, a ball is a wicket. This reduces the number of balls and wickets left by 1 without changing the number of runs. (This assumes that no runs are made on a ball with a wicket, such as when a high near-six is caught near the boundary and the batsmen have already completed one or more runs.)</li>
<li>otherwise, with certain probabilities, which depend on the number of balls and wickets left, a certain number of runs is scored.</li>
</ul>
</div>
<div id="probability-of-extra" class="section level2">
<h2>Probability of extra</h2>
<p>Estimating the “extra” probability is the easiest, since that doesn’t (by hypothesis) depend on anything else:</p>
<pre class="r"><code>d %&gt;% summarize(pEx=sum(isExtra)/nrow(d)) %&gt;% select(pEx) -&gt; pExtra
pExtra</code></pre>
<pre><code>## # A tibble: 1 x 1
##          pEx
##        &lt;dbl&gt;
## 1 0.02616932</code></pre>
<p>This is about half the corresponding value in <span class="citation">@carter2004cricket</span>.</p>
</div>
<div id="probability-of-wicket" class="section level2">
<h2>Probability of wicket</h2>
<p>The probability of a wicket is modelled using a logistic model (a probit model in <span class="citation">@carter2004cricket</span>); the log-odds of a wicket is modelled as a quadratic function of the number of balls and wickets left.</p>
<p>Thus our first step is to calculate the number of balls and wickets left, and then to remove the rows with extras:</p>
<pre class="r"><code>d %&gt;% mutate(ballsLeft=300-totalBalls,
            wktsLeft=10-wktDown) %&gt;%
  filter(!isExtra) -&gt; d1</code></pre>
<p>and now we can model:</p>
<pre class="r"><code>wModel=glm(isWkt~ballsLeft+wktsLeft+I(ballsLeft^2),data=d1,family=&quot;binomial&quot;) 
summary(wModel)</code></pre>
<pre><code>## 
## Call:
## glm(formula = isWkt ~ ballsLeft + wktsLeft + I(ballsLeft^2), 
##     family = &quot;binomial&quot;, data = d1)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -0.7582  -0.2410  -0.1954  -0.1590   3.2174  
## 
## Coefficients:
##                  Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)    -1.109e+00  3.091e-02  -35.87   &lt;2e-16 ***
## ballsLeft      -9.177e-03  4.845e-04  -18.94   &lt;2e-16 ***
## wktsLeft       -4.029e-01  6.681e-03  -60.30   &lt;2e-16 ***
## I(ballsLeft^2)  4.825e-05  1.613e-06   29.91   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 76107  on 299896  degrees of freedom
## Residual deviance: 70377  on 299893  degrees of freedom
## AIC: 70385
## 
## Number of Fisher Scoring iterations: 7</code></pre>
<p>Everything here is strongly significant, as would be expected with so much data. (These are the same explanatory variables as used by <span class="citation">@carter2004cricket</span>.)</p>
<p>We can make a table of predicted probability of a ball being a wicket as a function of the number of balls and wickets left:</p>
<pre class="r"><code>new=expand.grid(wktsLeft=c(1,5,10),ballsLeft=c(1,100,200,300))
p=predict(wModel,new,type=&quot;response&quot;)
data.frame(new,p)</code></pre>
<pre><code>##    wktsLeft ballsLeft           p
## 1         1         1 0.179338444
## 2         5         1 0.041787135
## 3        10         1 0.005782970
## 4         1       100 0.124889986
## 5         5       100 0.027691119
## 6        10       100 0.003784241
## 7         1       200 0.195104269
## 8         5       200 0.046140556
## 9        10       200 0.006410539
## 10        1       300 0.519366763
## 11        5       300 0.177388823
## 12       10       300 0.027957981</code></pre>
<p>For a fixed number of balls left, the probability of a wicket is higher if there are fewer wickets left. The pattern for a fixed number of balls left is unclear, but then in practice if there are many balls left, there are unlikely to be few wickets left.</p>
</div>
<div id="modelling-the-number-of-runs" class="section level2">
<h2>Modelling the number of runs</h2>
<p><span class="citation">@carter2004cricket</span> consider the number of runs on any ball as an ordered response, and model the probit of the probability of landing in each category as a quadratic function of the number of balls and wickets left. We use an ordered logistic model, using the <code>polr</code> function from library <code>MASS</code>. First, however, we need to remove the wicket balls from the data frame used to estimate the wickets process, and we need to turn the <code>totalRuns</code> on each ball into an ordered factor:</p>
<pre class="r"><code>d1 %&gt;% mutate(rf=ordered(totalRuns)) %&gt;% 
  filter(!isWkt) -&gt; d2</code></pre>
<p>and then down to business:</p>
<pre class="r"><code>library(MASS)</code></pre>
<pre><code>## 
## Attaching package: &#39;MASS&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:dplyr&#39;:
## 
##     select</code></pre>
<pre class="r"><code>rModel=polr(rf~ballsLeft+wktsLeft+I(ballsLeft^2),data=d2)</code></pre>
<p>The summary of the model is not very illuminating, so again we show predictions. In the output below, the number of runs is turned into column names for a data frame by appending an X:</p>
<pre class="r"><code>p=predict(rModel,new,type=&quot;probs&quot;)
data.frame(new,round(p,3))</code></pre>
<pre><code>##    wktsLeft ballsLeft    X0    X1    X2    X3    X4    X5    X6
## 1         1         1 0.399 0.398 0.073 0.009 0.102 0.000 0.019
## 2         5         1 0.242 0.411 0.109 0.015 0.183 0.001 0.039
## 3        10         1 0.114 0.317 0.132 0.021 0.323 0.001 0.092
## 4         1       100 0.680 0.246 0.029 0.004 0.035 0.000 0.006
## 5         5       100 0.506 0.352 0.053 0.007 0.069 0.000 0.013
## 6        10       100 0.291 0.417 0.097 0.013 0.151 0.000 0.031
## 7         1       200 0.836 0.132 0.013 0.002 0.015 0.000 0.003
## 8         5       200 0.711 0.225 0.025 0.003 0.031 0.000 0.005
## 9        10       200 0.497 0.357 0.055 0.007 0.072 0.000 0.013
## 10        1       300 0.901 0.081 0.007 0.001 0.008 0.000 0.001
## 11        5       300 0.814 0.148 0.015 0.002 0.017 0.000 0.003
## 12       10       300 0.638 0.274 0.034 0.004 0.042 0.000 0.007</code></pre>
<p>For any fixed number of balls left, if there are fewer wickets left, there is a higher chance of a “dot ball” (no runs), and a lower chance of a boundary (4 or 6 runs, in the columns labelled <code>X4</code> and <code>X6</code>). Also, for a fixed number of wickets left, there is a higher chance of a dot ball when many balls are left and a higher chance of a boundary with few balls left. These accord with intuition.</p>
</div>
</div>
<div id="constructing-the-recursion" class="section level1">
<h1>Constructing the recursion</h1>
<p>Let <span class="math inline">\(F(r; b, w)\)</span> denote the probability of a team scoring <span class="math inline">\(r\)</span> runs or fewer with <span class="math inline">\(b\)</span> balls and <span class="math inline">\(w\)</span> wickets left. There are some boundary cases: if there are no balls or wickets left, then a team scores 0 (more) runs with probability 1. Thus <span class="math inline">\(F(r;0,w)=1, F(r;b,0)=1\)</span> for <span class="math inline">\(r \ge 0\)</span>, and (for completeness) <span class="math inline">\(F(r;b,w)=0\)</span> for <span class="math inline">\(r&lt;0\)</span>. These form the base cases for a recursion. To evaluate <span class="math inline">\(F(r;b,w)\)</span> in general, consider what might happen on the next ball: an extra, in which case the team needs <span class="math inline">\(r-1\)</span> runs from <span class="math inline">\(b\)</span> balls with <span class="math inline">\(w\)</span> wickets left; a wicket, in which case the team needs <span class="math inline">\(r\)</span> runs from <span class="math inline">\(b-1\)</span> balls with <span class="math inline">\(w-1\)</span> wickets left, or <span class="math inline">\(j\)</span> runs are scored, in which case the team needs <span class="math inline">\(r-j\)</span> runs from <span class="math inline">\(b-1\)</span> balls with <span class="math inline">\(w\)</span> wickets left. Details can be found in <span class="citation">@carter2004cricket [page 826]</span>.</p>
<p>As an example, suppose we wish to find <span class="math inline">\(F(4;3,2)\)</span>. We need the probability of an extra, a wicket and each number of runs at this point:</p>
<pre class="r"><code>new=data.frame(ballsLeft=3,wktsLeft=2)
pExtra</code></pre>
<pre><code>## # A tibble: 1 x 1
##          pEx
##        &lt;dbl&gt;
## 1 0.02616932</code></pre>
<pre class="r"><code>predict(wModel,new,type=&quot;response&quot;)</code></pre>
<pre><code>##         1 
## 0.1254596</code></pre>
<pre class="r"><code>predict(rModel,new,type=&quot;probs&quot;)</code></pre>
<pre><code>##            0            1            2            3            4 
## 0.3618481772 0.4080933004 0.0804909684 0.0106283094 0.1161361034 
##            5            6 
## 0.0003392157 0.0224639254</code></pre>
Thus, the probability of an extra is 0.026, the probability of a wicket given a non-extra is 0.126, and the probabilities of <span class="math inline">\(0, 1, 2, \ldots\)</span> runs, given that there was neither an extra nor a wicket, are <span class="math inline">\(0.363, 0.408, 0.080, \ldots\)</span>. In detail, therefore, the recursion says that
<span class="math display">\[\begin{eqnarray*}
F(4;3,2)&amp;=&amp;0.026 F(3;3,2)+ (1-0.026)(0.126) F(4;2,1)+\\
&amp;&amp;(1-0.026)(1-0.126)\left[ 0.363 F(4;2,2) + 0.408F(3;2,2)+\right.\\
&amp;&amp;0.080 F(2;2,2)+0.011 F(1;2,2)+0.116 F(0;2,2)+\\
&amp;&amp;\left. 0.0003 F(-1;2,2)+0.022F(-2;2,2)\right] \\
\end{eqnarray*}\]</span>
<p>We note that <span class="math inline">\(F(-1;2,2)=F(-2;2,2)=0\)</span> (in words, the probability of getting 4 runs or less in 3 balls is 0 if 5 or 6 runs are scored off the first ball). The remaining <span class="math inline">\(F(r;b,w)\)</span> need to be calculated, and this is done using a similar recursion. Note that, for example, <span class="math inline">\(F(3;3,2)\)</span> will also need <span class="math inline">\(F(2;2,2)\)</span> (if one run is scored off the next ball), and thus a naive recursion would do a lot of unnecessary re-calculation. It is important, therefore, to create a look-up table of values already calculated, and to check it before starting on a calculation. In pseudocode, the procedure is therefore this:</p>
<pre><code>bigF=function(r,b,w) {
  # base cases
  if (r&lt;0) return 0
  if (b==0) return 1
  if (w==0) return 1
  # lookup table
  if (r,b,w) in lookup table, return value
  # else recurse
  obtain probability of extra PE, wicket PW, and array P[j] each number of runs j this ball
  sum=0
  for (j in 0:6) {
    sum=sum+P[j]*bigF(r-j,b-1,w)
  }
  ans=PE*bigF(r-1,b,w)+(1-PE)*PW*bigF(r,b-1,w-1)+(1-PE)*(1-PW)*sum
  save ans in lookup table
  return ans
}
</code></pre>
<p>Let <span class="math inline">\(F\)</span> be the probability of scoring <span class="math inline">\(r\)</span> runs or less with <span class="math inline">\(b\)</span> balls and <span class="math inline">\(w\)</span> wickets remaining. There are two choices for the data structure for the lookup table. One is a three-dimensional array (dimensions runs, balls and wickets, with the value of the array being <span class="math inline">\(F\)</span>), and the other is a data frame, with columns for runs, balls, wickets and <span class="math inline">\(F\)</span>. I chose the latter, because of the simplicity of using <code>dplyr::filter</code> to see whether a row exists yet. (The notation <span class="math inline">\(F\)</span> is a reminder that this is a <em>cumulative</em> probability, that many runs or less.)</p>
<p>We will keep the lookup table as a data frame called <code>lookupTable</code>, dimensions runs, balls and wickets left in that order, initialized as empty and kept in an environment called <code>env</code> (so that we can access and change it from within a function):</p>
<pre class="r"><code>max.runs=400
max.balls=300
max.wickets=10
env=new.env(parent=emptyenv())
aa=data.frame(rr=integer(),bb=integer(),ww=integer(),F=double())
env$lookupTable=aa
str(env$lookupTable)</code></pre>
<pre><code>## &#39;data.frame&#39;:    0 obs. of  4 variables:
##  $ rr: int 
##  $ bb: int 
##  $ ww: int 
##  $ F : num</code></pre>
<p>Then we implement the function outlined in pseudocode above:</p>
<pre class="r"><code>bigF=function(r,b,w) {
  # base cases
  if (r&lt;0) return(0)
  if (b==0) return(1)
  if (w==0) return(1)
  # return value if in lookup table
  tab=get(&quot;lookupTable&quot;,envir=env)
  tab %&gt;% filter(rr==r, bb==b, ww==w) -&gt; x
  if (nrow(x)&gt;0) return(x[1,4])
  # recursion
  new=data.frame(ballsLeft=b,wktsLeft=w)
  pW=predict(wModel,new,type=&quot;response&quot;)
  p=predict(rModel,new,type=&quot;probs&quot;)
  pE=as.numeric(pExtra[1,1]) # global variable
  sum=0
  for (j in 0:6) {
    sum=sum+p[j+1]*bigF(r-j,b-1,w)
  }
  ans=pE*bigF(r-1,b,w)+(1-pE)*pW*bigF(r,b-1,w-1)+(1-pE)*(1-pW)*sum
  names(ans)=NULL
  # lookup table might have changed since earlier, so get again before altering
  tab=get(&quot;lookupTable&quot;,envir=env)
  tab=rbind(tab,data.frame(rr=r,bb=b,ww=w,F=ans))
  assign(&quot;lookupTable&quot;,value=tab,envir=env)
  return(ans)
}</code></pre>
<p>Let’s test it with the example we used above, and at the same time, time it:</p>
<pre class="r"><code>system.time(ans &lt;- bigF(4,3,2))</code></pre>
<pre><code>##    user  system elapsed 
##   0.320   0.000   0.319</code></pre>
<pre class="r"><code>ans</code></pre>
<pre><code>## [1] 0.721199</code></pre>
<p>This result is reasonable, since with only three balls and two wickets left, it is most likely that four runs or fewer will be scored. I had to use the “alternative” arrow-like assignment operator here, because an equals sign inside <code>system.time</code> has a different meaning. We will assess the times in a moment.</p>
<p>It would be interesting to see what the lookup table looks like (that is, which values have been calculated). This is a data frame, so can just be displayed, or we can sort by something. I wanted to see the cumulative distribution of runs given a number of balls and wickets remaining:</p>
<pre class="r"><code>env$lookupTable %&gt;% arrange(bb,ww,rr)</code></pre>
<pre><code>##    rr bb ww          F
## 1   0  1  1 0.49321063
## 2   1  1  1 0.82404148
## 3   2  1  1 0.89087956
## 4   3  1  1 0.90020778
## 5   4  1  1 0.98174689
## 6   0  1  2 0.42641663
## 7   1  1  2 0.78550080
## 8   2  1  2 0.86441506
## 9   3  1  2 0.87568180
## 10  4  1  2 0.97686396
## 11  0  2  1 0.33198089
## 12  1  2  1 0.60371717
## 13  2  2  1 0.76588781
## 14  3  2  1 0.81717688
## 15  4  2  1 0.89376016
## 16  0  2  2 0.19088917
## 17  1  2  2 0.49451548
## 18  2  2  2 0.68908943
## 19  3  2  2 0.75489255
## 20  4  2  2 0.85277871
## 21  0  3  2 0.09938645
## 22  1  3  2 0.29509984
## 23  2  3  2 0.49860893
## 24  3  3  2 0.62064608
## 25  4  3  2 0.72119896</code></pre>
<p>Because the lookup table has now been populated, running the same calculation again should be a lot quicker:</p>
<pre class="r"><code>system.time(ans &lt;- bigF(4,3,2))</code></pre>
<pre><code>##    user  system elapsed 
##   0.004   0.000   0.002</code></pre>
<pre class="r"><code>ans</code></pre>
<pre><code>## [1] 0.721199</code></pre>
<p>And so it is.</p>
</div>
<div id="applications" class="section level1">
<h1>Applications</h1>
<p>The nature of this recursion, with 8 recursive calls to <code>bigF</code> inside one original call, means that we threaten to branch wildly and will need to keep a large number of <span class="math inline">\((r,b,w)\)</span> triples on the stack. This is obviated by calling <code>bigF</code> repeatedly with values of <span class="math inline">\(r,b,w\)</span> only a little bigger than those already in the lookup table, taking advantage of the calculations already done (which will be most of the ones we need). For example:</p>
<pre class="r"><code>system.time(bigF(10,10,10))</code></pre>
<pre><code>##    user  system elapsed 
##   9.268   0.004   9.282</code></pre>
<p>showing, for example, the cumulative distribution of runs with 8 balls and 9 wickets left (as calculated so far):</p>
<pre class="r"><code>env$lookupTable %&gt;% filter(bb==8, ww==9) %&gt;% arrange(rr)</code></pre>
<pre><code>##    rr bb ww            F
## 1   0  8  9 2.551895e-07
## 2   1  8  9 4.656748e-06
## 3   2  8  9 4.021283e-05
## 4   3  8  9 2.180352e-04
## 5   4  8  9 8.361319e-04
## 6   5  8  9 2.445443e-03
## 7   6  8  9 5.816592e-03
## 8   7  8  9 1.195466e-02
## 9   8  8  9 2.226083e-02
## 10  9  8  9 3.841906e-02
## 11 10  8  9 6.183717e-02</code></pre>
<p>and then</p>
<pre class="r"><code>system.time(bigF(20,15,10))</code></pre>
<pre><code>##    user  system elapsed 
##  32.728   0.008  32.744</code></pre>
<p>after which, one can extract the more complete cumulative distribution of runs with 8 balls and 9 wickets left, thus:</p>
<pre class="r"><code>env$lookupTable %&gt;% filter(bb==8, ww==9) %&gt;% arrange(rr)</code></pre>
<pre><code>##    rr bb ww            F
## 1   0  8  9 2.551895e-07
## 2   1  8  9 4.656748e-06
## 3   2  8  9 4.021283e-05
## 4   3  8  9 2.180352e-04
## 5   4  8  9 8.361319e-04
## 6   5  8  9 2.445443e-03
## 7   6  8  9 5.816592e-03
## 8   7  8  9 1.195466e-02
## 9   8  8  9 2.226083e-02
## 10  9  8  9 3.841906e-02
## 11 10  8  9 6.183717e-02
## 12 11  8  9 9.355500e-02
## 13 12  8  9 1.346290e-01
## 14 13  8  9 1.854712e-01
## 15 14  8  9 2.450907e-01
## 16 15  8  9 3.121335e-01
## 17 16  8  9 3.851316e-01
## 18 17  8  9 4.612746e-01
## 19 18  8  9 5.375758e-01
## 20 19  8  9 6.119761e-01
## 21 20  8  9 6.818799e-01</code></pre>
<p>From there, on it goes, in small steps.</p>
</div>

    </div>
  </article>

  <div id="disqus_thread"></div>
<script>
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://kens-blog-2.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="../../../../index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="../../../../images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.10.0/highlight.min.js"></script>

<script src="//cdn.bootcss.com/highlight.js/9.10.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.10.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="../../../../js/math-code.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script async type="text/javascript"
  src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
  </body>
</html>

